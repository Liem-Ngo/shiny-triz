<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRIZ Principle: Spheroidality - Curvature</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23e0e0e0' fill-opacity='0.4' fill-rule='evenodd'%3E%3Cpath d='M0 0h10v10H0V0zm10 10h10v10H10V10zm10-10h10v10H20V0zm10 10h10v10H30V10zm10-10h10v10H40V0zm10 10h10v10H50V10zM0 20h10v10H0V20zm10 10h10v10H10V30zm10-10h10v10H20V20zm10 10h10v10H30V30zm10-10h10v10H40V20zm10 10h10v10H50V30zM0 40h10v10H0V40zm10 10h10v10H10V50zm10-10h10v10H20V40zm10 10h10v10H30V50zm10-10h10v10H40V40zm10 10h10v10H50V50z'/%3E%3C/g%3E%3C/svg%3E");
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .explanation, .visualization {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .visualization {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        h2 {
            color: #3498db;
            margin-bottom: 20px;
        }
        
        h3 {
            color: #2980b9;
            margin-bottom: 15px;
        }
        
        ul {
            margin-bottom: 20px;
        }
        
        .canvas-container {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin: 20px 0;
        }
        
        .wall-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        canvas {
            border: 1px solid #ddd;
            background-color: #fff;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
            border-radius: 4px;
        }
        
        .timer {
            margin: 10px 0;
            font-size: 16px;
            font-weight: bold;
        }
        
        .controls {
            margin: 20px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        button:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .hidden {
            display: none;
        }
        
        .settings {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .setting-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        select, input {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        
        .paint-tray {
            width: 120px;
            height: 40px;
            background-color: #777;
            border-radius: 5px 5px 0 0;
            margin-top: 20px;
            position: relative;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
            overflow: hidden;
            transform: perspective(300px) rotateX(10deg);
        }
        
        .paint-tray:before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 30px;
            background-color: var(--paint-color, #4b86b4);
            border-radius: 5px 5px 0 0;
            background-image: 
                linear-gradient(rgba(255,255,255,0.4) 0%, rgba(255,255,255,0.1) 30%, rgba(0,0,0,0.05) 50%, rgba(0,0,0,0.1) 70%, rgba(0,0,0,0.2) 100%),
                linear-gradient(90deg, rgba(255,255,255,0.3), rgba(255,255,255,0), rgba(255,255,255,0.3));
        }
        
        .legend {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .color-swatch {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #ddd;
        }
        
        .result {
            margin-top: 20px;
            padding: 15px;
            background-color: #f1f9f9;
            border-radius: 8px;
            border-left: 4px solid #3498db;
            max-width: 600px;
        }
        
        @keyframes drip {
            0% {
                height: 0;
                opacity: 0.8;
            }
            70% {
                height: 15px;
                opacity: 0.7;
            }
            100% {
                height: 20px;
                opacity: 0.5;
                transform: scaleX(0.8);
            }
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; }
            20% { opacity: 0.7; }
            80% { opacity: 0.7; }
            100% { opacity: 0; }
        }
        
        .paint-splatter {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            animation: fadeInOut 1s forwards;
        }
        
        .animated-drip {
            position: absolute;
            width: 2px;
            bottom: 0;
            animation: drip 3s forwards;
        }
        
        @media (max-width: 768px) {
            .canvas-container {
                flex-direction: column;
                align-items: center;
            }
            
            .wall-container {
                margin-bottom: 30px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>TRIZ Principle: Spheroidality - Curvature</h1>
        <h2>Roller Brush vs. Flat Brush Comparison</h2>
    </div>
    
    <div class="explanation">
        <h3>Why Curvature Matters: The Roller Brush Example</h3>
        <p>A roller brush, with its cylindrical shape, is much more efficient than a flat brush for painting large surfaces. This demonstrates the TRIZ principle of Spheroidality - Curvature, where changing from flat to curved surfaces can improve performance.</p>
        <ul>
            <li><strong>Maintain continuous contact</strong> - The curved surface of a roller brush allows it to maintain continuous contact with the wall as it moves up and down, distributing paint efficiently regardless of direction.</li>
            <li><strong>Cover a larger area</strong> - A roller brush can cover significantly more surface area in a single pass compared to a flat brush due to its wider contact surface.</li>
            <li><strong>Distribute paint consistently</strong> - The cylindrical shape helps distribute paint evenly across the surface, reducing streaks and unevenness even during direction changes.</li>
        </ul>
        <p>In contrast, a flat brush requires more strokes, more frequent reloading with paint, and produces less consistent results on large surfaces. The simulation below demonstrates this difference in efficiency as the brushes move vertically up and down the wall.</p>
    </div>
    
    <div class="visualization">
        <h3>Interactive Visualization</h3>
        <p>Click the "Start Painting" button below to watch how much faster a roller brush paints a wall compared to a flat brush. Watch how the wall changes color as the brushes move up and down!</p>
        
        <div class="settings">
            <div class="setting-group">
                <label for="paintColor">Paint Color:</label>
                <select id="paintColor">
                    <option value="#4b86b4">Blue</option>
                    <option value="#2ecc71">Green</option>
                    <option value="#e74c3c">Red</option>
                    <option value="#f39c12">Orange</option>
                    <option value="#9b59b6">Purple</option>
                    <option value="#3498db">Sky Blue</option>
                    <option value="#e67e22">Amber</option>
                    <option value="#16a085">Teal</option>
                </select>
            </div>
            <div class="setting-group">
                <label for="speedFactor">Speed:</label>
                <input type="range" id="speedFactor" min="0.5" max="2" step="0.1" value="1">
            </div>
        </div>
        
        <div class="legend">
            <div class="color-swatch" id="colorSwatch"></div>
            <span>Selected Paint Color</span>
        </div>
        
        <div class="canvas-container">
            <div class="wall-container">
                <h4>Roller Brush</h4>
                <canvas id="rollerCanvas" width="400" height="300"></canvas>
                <div class="timer" id="rollerTimer">Time: 0.0s</div>
                <div class="paint-tray" id="rollerTray"></div>
            </div>
            <div class="wall-container">
                <h4>Flat Brush</h4>
                <canvas id="flatCanvas" width="400" height="300"></canvas>
                <div class="timer" id="flatTimer">Time: 0.0s</div>
                <div class="paint-tray" id="flatTray"></div>
            </div>
        </div>
        
        <div class="controls">
            <div class="button-group">
                <button id="startButton">Start Painting</button>
                <button id="stopButton" class="hidden">Stop Painting</button>
                <button id="resetButton" class="hidden">Reset</button>
            </div>
        </div>
        
        <div class="result hidden" id="resultText">
            <p>The roller brush completed painting in <span id="rollerTime"></span> seconds, while the flat brush took <span id="flatTime"></span> seconds.</p>
            <p>This demonstrates that the roller brush is approximately <span id="efficiencyFactor"></span>x more efficient, highlighting the advantage of curved surfaces (spheroidality) in this application.</p>
            <p>Note how the curved surface of the roller brush maintains consistent contact with the wall during up and down movements, while the flat brush has more limited contact area.</p>
        </div>
    </div>
    
    <script>
        // DOM References
        const rollerCanvas = document.getElementById('rollerCanvas');
        const flatCanvas = document.getElementById('flatCanvas');
        const rollerCtx = rollerCanvas.getContext('2d');
        const flatCtx = flatCanvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const resetButton = document.getElementById('resetButton');
        const rollerTimer = document.getElementById('rollerTimer');
        const flatTimer = document.getElementById('flatTimer');
        const resultText = document.getElementById('resultText');
        const rollerTimeSpan = document.getElementById('rollerTime');
        const flatTimeSpan = document.getElementById('flatTime');
        const efficiencyFactorSpan = document.getElementById('efficiencyFactor');
        const paintColorSelect = document.getElementById('paintColor');
        const speedFactorInput = document.getElementById('speedFactor');
        const colorSwatch = document.getElementById('colorSwatch');
        const rollerTray = document.getElementById('rollerTray');
        const flatTray = document.getElementById('flatTray');
        
        // Constants
        const WALL_WIDTH = 400;
        const WALL_HEIGHT = 300;
        const ROLLER_WIDTH = 40;
        const ROLLER_HEIGHT = 20;
        const FLAT_BRUSH_WIDTH = 40; // Now same as roller width
        const FLAT_BRUSH_HEIGHT = 10;
        const BASE_PASS_DURATION = 500; // ms per vertical pass
        const FLAT_BRUSH_SLOWDOWN = 2.5; // Flat brush is 2.5x slower
        const HORIZONTAL_STEP = ROLLER_WIDTH / 2; // Each pass moves right by half the roller width
        const FLAT_HORIZONTAL_STEP = FLAT_BRUSH_WIDTH / 2; // Now matches the roller step
        const MAX_PAINT_CAPACITY = 3; // Number of passes before reload
        
        // Paint tracking arrays - store which areas have been painted
        let rollerPaintedAreas = [];
        let flatPaintedAreas = [];
        
        // State variables
        let rollerX = 0;
        let rollerY = 0;
        let rollerDirection = 1; // 1 = down, -1 = up
        let rollerPassCount = 0;
        let rollerFinishTime = null;
        let rollerPaintLevel = MAX_PAINT_CAPACITY;
        
        let flatX = 0;
        let flatY = 0;
        let flatDirection = 1; // 1 = down, -1 = up
        let flatPassCount = 0;
        let flatFinishTime = null;
        let flatPaintLevel = MAX_PAINT_CAPACITY;
        
        let animationId = null;
        let startTime = null;
        let paintColor = paintColorSelect.value;
        let speedFactor = parseFloat(speedFactorInput.value);
        
        // Initialize
        init();
        
        // Event listeners
        startButton.addEventListener('click', startAnimation);
        stopButton.addEventListener('click', stopAnimation);
        resetButton.addEventListener('click', resetAnimation);
        
        paintColorSelect.addEventListener('change', function() {
            paintColor = paintColorSelect.value;
            updatePaintTrayColor();
            colorSwatch.style.backgroundColor = paintColor;
            init();
        });
        
        speedFactorInput.addEventListener('input', function() {
            speedFactor = parseFloat(speedFactorInput.value);
        });
        
        // Initialize display
        function init() {
            // Reset paint tracking arrays
            rollerPaintedAreas = [];
            flatPaintedAreas = [];
            
            // Clear canvases
            rollerCtx.clearRect(0, 0, WALL_WIDTH, WALL_HEIGHT);
            flatCtx.clearRect(0, 0, WALL_WIDTH, WALL_HEIGHT);
            
            // Draw initial white wall with texture
            drawUnpaintedWall(rollerCtx);
            drawUnpaintedWall(flatCtx);
            
            // Reset state
            rollerX = 0;
            rollerY = 0;
            rollerDirection = 1; // Start moving down
            rollerPassCount = 0;
            rollerFinishTime = null;
            rollerPaintLevel = MAX_PAINT_CAPACITY;
            
            flatX = 0;
            flatY = 0;
            flatDirection = 1; // Start moving down
            flatPassCount = 0;
            flatFinishTime = null;
            flatPaintLevel = MAX_PAINT_CAPACITY;
            
            // Reset UI
            rollerTimer.textContent = 'Time: 0.0s';
            flatTimer.textContent = 'Time: 0.0s';
            resultText.classList.add('hidden');
            
            // Update paint color
            paintColor = paintColorSelect.value;
            colorSwatch.style.backgroundColor = paintColor;
            updatePaintTrayColor();
            
            // Draw initial brush positions
            drawBrush(rollerCtx, rollerX, rollerY, ROLLER_WIDTH, ROLLER_HEIGHT, true, rollerPaintLevel);
            drawBrush(flatCtx, flatX, flatY, FLAT_BRUSH_WIDTH, FLAT_BRUSH_HEIGHT, false, flatPaintLevel);
        }
        
        // Draw unpainted wall with texture
        function drawUnpaintedWall(ctx) {
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, WALL_WIDTH, WALL_HEIGHT);
            
            // Add subtle wall texture
            ctx.fillStyle = 'rgba(0, 0, 0, 0.02)';
            for (let i = 0; i < WALL_WIDTH; i += 10) {
                for (let j = 0; j < WALL_HEIGHT; j += 10) {
                    if (Math.random() > 0.7) {
                        ctx.fillRect(i, j, 1, 1);
                    }
                }
            }
            
            // Add very subtle shadows at edges
            const gradient = ctx.createLinearGradient(0, 0, WALL_WIDTH, 0);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.05)');
            gradient.addColorStop(0.05, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(0.95, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.05)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, WALL_WIDTH, WALL_HEIGHT);
        }
        
        function updatePaintTrayColor() {
            document.documentElement.style.setProperty('--paint-color', paintColor);
            document.head.appendChild(document.createElement('style')).innerHTML = 
                `.paint-tray:before { background-color: ${paintColor}; }`;
        }
        
        function startAnimation() {
            if (animationId) return;
            
            startButton.classList.add('hidden');
            stopButton.classList.remove('hidden');
            resetButton.classList.remove('hidden');
            
            startTime = performance.now();
            animationId = requestAnimationFrame(animate);
        }
        
        function stopAnimation() {
            if (!animationId) return;
            
            cancelAnimationFrame(animationId);
            animationId = null;
            
            stopButton.classList.add('hidden');
            startButton.classList.remove('hidden');
        }
        
        function resetAnimation() {
            stopAnimation();
            init();
            
            resetButton.classList.add('hidden');
        }
        
        function animate(timestamp) {
            const elapsedTime = timestamp - startTime;
            const elapsedSeconds = elapsedTime / 1000;
            
            // Redraw both canvases completely
            redrawCanvas(rollerCtx, rollerPaintedAreas);
            redrawCanvas(flatCtx, flatPaintedAreas);
            
            // Update roller brush
            if (!rollerFinishTime) {
                updateBrush(
                    timestamp, 
                    elapsedSeconds,
                    rollerX, 
                    rollerY, 
                    rollerDirection, 
                    rollerPassCount, 
                    rollerPaintLevel,
                    true, 
                    rollerCtx,
                    rollerPaintedAreas,
                    rollerTimer,
                    function(newX, newY, newDirection, newPassCount, newPaintLevel, finishTime) {
                        rollerX = newX;
                        rollerY = newY;
                        rollerDirection = newDirection;
                        rollerPassCount = newPassCount;
                        rollerPaintLevel = newPaintLevel;
                        rollerFinishTime = finishTime;
                        
                        if (finishTime) {
                            rollerTimeSpan.textContent = (finishTime / 1000).toFixed(1);
                            // When finished, paint the entire wall
                            rollerPaintedAreas = [{ 
                                x: 0, 
                                y: 0, 
                                width: WALL_WIDTH, 
                                height: WALL_HEIGHT 
                            }];
                            redrawCanvas(rollerCtx, rollerPaintedAreas);
                            drawBrush(rollerCtx, rollerX, rollerY, ROLLER_WIDTH, ROLLER_HEIGHT, true, rollerPaintLevel);
                            checkCompletion();
                        }
                    }
                );
            } else {
                // Just redraw the brush on the completed wall
                drawBrush(rollerCtx, rollerX, rollerY, ROLLER_WIDTH, ROLLER_HEIGHT, true, rollerPaintLevel);
                rollerTimer.textContent = `Time: ${(rollerFinishTime / 1000).toFixed(1)}s (Completed)`;
            }
            
            // Update flat brush
            if (!flatFinishTime) {
                updateBrush(
                    timestamp,
                    elapsedSeconds,
                    flatX,
                    flatY,
                    flatDirection,
                    flatPassCount,
                    flatPaintLevel,
                    false,
                    flatCtx,
                    flatPaintedAreas,
                    flatTimer,
                    function(newX, newY, newDirection, newPassCount, newPaintLevel, finishTime) {
                        flatX = newX;
                        flatY = newY;
                        flatDirection = newDirection;
                        flatPassCount = newPassCount;
                        flatPaintLevel = newPaintLevel;
                        flatFinishTime = finishTime;
                        
                        if (finishTime) {
                            flatTimeSpan.textContent = (finishTime / 1000).toFixed(1);
                            // When finished, paint the entire wall
                            flatPaintedAreas = [{ 
                                x: 0, 
                                y: 0, 
                                width: WALL_WIDTH, 
                                height: WALL_HEIGHT 
                            }];
                            redrawCanvas(flatCtx, flatPaintedAreas);
                            drawBrush(flatCtx, flatX, flatY, FLAT_BRUSH_WIDTH, FLAT_BRUSH_HEIGHT, false, flatPaintLevel);
                            checkCompletion();
                        }
                    }
                );
            } else {
                // Just redraw the brush on the completed wall
                drawBrush(flatCtx, flatX, flatY, FLAT_BRUSH_WIDTH, FLAT_BRUSH_HEIGHT, false, flatPaintLevel);
                flatTimer.textContent = `Time: ${(flatFinishTime / 1000).toFixed(1)}s (Completed)`;
            }
            
            // Continue animation if not done
            if (!rollerFinishTime || !flatFinishTime) {
                animationId = requestAnimationFrame(animate);
            }
        }
        
        // Redraw the entire canvas from scratch
        function redrawCanvas(ctx, paintedAreas) {
            // Clear the canvas
            ctx.clearRect(0, 0, WALL_WIDTH, WALL_HEIGHT);
            
            // Draw white base wall
            drawUnpaintedWall(ctx);
            
            // Draw each painted area
            paintedAreas.forEach(area => {
                drawPaintedArea(ctx, area.x, area.y, area.width, area.height, paintColor, area.isRoller);
            });
        }
        
        function updateBrush(timestamp, elapsedSeconds, x, y, direction, passCount, paintLevel, isRoller, ctx, paintedAreas, timerEl, updateCallback) {
            const width = isRoller ? ROLLER_WIDTH : FLAT_BRUSH_WIDTH;
            const height = isRoller ? ROLLER_HEIGHT : FLAT_BRUSH_HEIGHT;
            const horizontalStep = isRoller ? HORIZONTAL_STEP : FLAT_HORIZONTAL_STEP;
            const speed = BASE_PASS_DURATION * (isRoller ? 1 : FLAT_BRUSH_SLOWDOWN) / speedFactor;
            
            // Update timer
            timerEl.textContent = `Time: ${elapsedSeconds.toFixed(1)}s`;
            
            // Calculate position based on time
            const cycleDuration = speed;
            const cycleProgress = (timestamp % cycleDuration) / cycleDuration;
            
            // Calculate new Y position with easing
            let newY;
            if (direction === 1) {
                // Easing function for downward movement - ease-in-out
                const progress = cycleProgress;
                if (progress < 0.5) {
                    // Accelerate (ease in)
                    newY = WALL_HEIGHT * (2 * progress * progress);
                } else {
                    // Decelerate (ease out)
                    const t = progress - 1;
                    newY = WALL_HEIGHT * (1 - 2 * t * t);
                }
            } else {
                // Easing function for upward movement - ease-in-out
                const progress = 1 - cycleProgress;
                if (progress < 0.5) {
                    // Accelerate (ease in)
                    newY = WALL_HEIGHT * (1 - 2 * progress * progress);
                } else {
                    // Decelerate (ease out)
                    const t = progress - 1;
                    newY = WALL_HEIGHT * (2 * t * t);
                }
            }
            
            // If we've completed a pass
            if ((direction === 1 && cycleProgress < 0.1 && y > WALL_HEIGHT * 0.9) ||
                (direction === -1 && cycleProgress < 0.1 && y < WALL_HEIGHT * 0.1)) {
                
                // Add the painted area from this pass
                paintedAreas.push({
                    x: x,
                    y: 0,
                    width: width,
                    height: WALL_HEIGHT,
                    isRoller: isRoller
                });
                
                // Update direction and pass count
                const newDirection = -direction;
                const newPassCount = passCount + 1;
                
                // Update paint level
                let newPaintLevel = paintLevel - 1;
                let finishTime = null;
                
                // Move brush right
                let newX = x + horizontalStep;
                
                // If we need to reload paint
                if (newPaintLevel <= 0) {
                    // Create paint drips
                    createPaintDrip(WALL_WIDTH / 2, 0, isRoller ? rollerTray : flatTray);
                    
                    // Reset paint level
                    newPaintLevel = MAX_PAINT_CAPACITY;
                }
                
                // Check if we've completed painting
                if (newX + width >= WALL_WIDTH) {
                    finishTime = timestamp - startTime;
                    newX = WALL_WIDTH - width;
                }
                
                // Update callback
                updateCallback(newX, newY, newDirection, newPassCount, newPaintLevel, finishTime);
            } else {
                // Normal movement with painting in progress
                
                // Add the current brush position area to be painted
                // Only add new paint where the brush currently is
                const paintHeight = height; // Only current brush height
                const paintY = newY; // Current Y position
                
                // Paint the current area
                paintedAreas.push({
                    x: x,
                    y: paintY,
                    width: width,
                    height: paintHeight,
                    isRoller: isRoller
                });
                
                // Occasional paint splatters for realism
                if (Math.random() > 0.95 && paintLevel > 1) {
                    createSplatter(x + width * Math.random(), newY + height * Math.random(), 
                             ctx.canvas.parentElement, paintColor);
                }
                
                // Update callback with normal movement
                updateCallback(x, newY, direction, passCount, paintLevel, null);
            }
            
            // Always draw the brush at the end
            drawBrush(ctx, x, newY, width, height, isRoller, paintLevel);
        }
        
        function drawBrush(ctx, x, y, width, height, isRoller, paintLevel) {
            if (isRoller) {
                drawRollerBrush(ctx, x, y, width, height, paintLevel);
            } else {
                drawFlatBrush(ctx, x, y, width, height, paintLevel);
            }
        }
        
        function drawRollerBrush(ctx, x, y, width, height, paintLevel) {
            // Draw handle
            drawHandle(ctx, x, y, width);
            
            // Draw roller frame
            drawRollerFrame(ctx, x, y, width, height);
            
            // Draw roller cover with paint
            drawRollerCover(ctx, x, y, width, height, paintLevel);
        }
        
        function drawHandle(ctx, x, y, width) {
            const handleWidth = 8;
            const handleHeight = 40;
            const handleX = x + width / 2 - handleWidth / 2;
            const handleY = y - handleHeight;
            
            // Wooden gradient
            const gradient = ctx.createLinearGradient(handleX, handleY, handleX + handleWidth, handleY);
            gradient.addColorStop(0, '#8B4513');
            gradient.addColorStop(0.4, '#A0522D');
            gradient.addColorStop(0.6, '#CD853F');
            gradient.addColorStop(1, '#A0522D');
            ctx.fillStyle = gradient;
            
            // Add 3D effect with slight curve for handle
            ctx.beginPath();
            ctx.moveTo(handleX, handleY);
            ctx.lineTo(handleX + handleWidth, handleY);
            ctx.lineTo(handleX + handleWidth - 1, handleY + handleHeight);
            ctx.lineTo(handleX + 1, handleY + handleHeight);
            ctx.closePath();
            ctx.fill();
            
            // Wood grain texture
            ctx.strokeStyle = 'rgba(80, 40, 20, 0.5)';
            ctx.lineWidth = 0.5;
            
            // Vertical grain lines
            for (let i = 1; i < handleWidth - 1; i += 2) {
                if (Math.random() > 0.3) {
                    const variance = Math.random() * 0.5;
                    ctx.beginPath();
                    ctx.moveTo(handleX + i, handleY);
                    
                    // Wavy line for natural wood grain
                    for (let j = 0; j < handleHeight; j += 5) {
                        const xOffset = (Math.random() - 0.5) * 1.5;
                        ctx.lineTo(handleX + i + xOffset, handleY + j);
                    }
                    
                    ctx.stroke();
                }
            }
            
            // Horizontal grip rings for ergonomics
            ctx.strokeStyle = 'rgba(60, 30, 15, 0.7)';
            for (let i = 0; i < 5; i++) {
                const ringY = handleY + 10 + i * 6;
                ctx.beginPath();
                ctx.moveTo(handleX, ringY);
                ctx.bezierCurveTo(
                    handleX + handleWidth * 0.25, ringY - 1,
                    handleX + handleWidth * 0.75, ringY - 1,
                    handleX + handleWidth, ringY
                );
                ctx.stroke();
            }
            
            // Handle highlight
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.beginPath();
            ctx.moveTo(handleX + 1, handleY + 1);
            ctx.lineTo(handleX + 1, handleY + handleHeight - 1);
            ctx.stroke();
            
            // Handle shadow
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.moveTo(handleX + handleWidth - 1, handleY + 1);
            ctx.lineTo(handleX + handleWidth - 1, handleY + handleHeight - 1);
            ctx.stroke();
        }
        
        function drawRollerFrame(ctx, x, y, width, height) {
            const radius = height / 2;
            
            // Metallic gradient for main frame
            const gradientVert = ctx.createLinearGradient(x, y - 5, x, y + height + 5);
            gradientVert.addColorStop(0, '#B8B8B8');
            gradientVert.addColorStop(0.3, '#E0E0E0');
            gradientVert.addColorStop(0.7, '#C0C0C0');
            gradientVert.addColorStop(1, '#A0A0A0');
            
            // Metal frame with rounded corners
            const frameWidth = 4;
            
            // Left arm (rounded rectangle with 3D effect)
            ctx.fillStyle = gradientVert;
            roundedRect(ctx, x - frameWidth, y - 5, frameWidth, height + 10, 2);
            
            // Right arm (rounded rectangle with 3D effect)
            roundedRect(ctx, x + width, y - 5, frameWidth, height + 10, 2);
            
            // Top connector with 3D effect
            const gradientHoriz = ctx.createLinearGradient(x - frameWidth, y - 5, x - frameWidth, y);
            gradientHoriz.addColorStop(0, '#C0C0C0');
            gradientHoriz.addColorStop(0.5, '#E8E8E8');
            gradientHoriz.addColorStop(1, '#C0C0C0');
            ctx.fillStyle = gradientHoriz;
            roundedRect(ctx, x - frameWidth, y - 5, width + frameWidth * 2, 5, 2);
            
            // Bottom connector
            ctx.fillStyle = gradientHoriz;
            roundedRect(ctx, x - frameWidth, y + height, width + frameWidth * 2, 5, 2);
            
            // Add screw details
            drawScrew(ctx, x - frameWidth/2, y - 3);
            drawScrew(ctx, x + width + frameWidth/2, y - 3);
            drawScrew(ctx, x - frameWidth/2, y + height + 3);
            drawScrew(ctx, x + width + frameWidth/2, y + height + 3);
            
            // Highlights on metal edges
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 1;
            
            // Left highlight
            ctx.beginPath();
            ctx.moveTo(x - frameWidth, y - 3);
            ctx.lineTo(x - frameWidth, y + height + 3);
            ctx.stroke();
            
            // Top highlight
            ctx.beginPath();
            ctx.moveTo(x - frameWidth + 1, y - 5);
            ctx.lineTo(x + width + frameWidth - 1, y - 5);
            ctx.stroke();
            
            // Add shadows
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            
            // Right shadow
            ctx.beginPath();
            ctx.moveTo(x + width + frameWidth, y - 3);
            ctx.lineTo(x + width + frameWidth, y + height + 3);
            ctx.stroke();
            
            // Bottom shadow
            ctx.beginPath();
            ctx.moveTo(x - frameWidth + 1, y + height + 5);
            ctx.lineTo(x + width + frameWidth - 1, y + height + 5);
            ctx.stroke();
        }
        
        function roundedRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
        }
        
        function drawScrew(ctx, x, y) {
            const radius = 1.5;
            // Screw head
            const screwGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
            screwGradient.addColorStop(0, '#E8E8E8');
            screwGradient.addColorStop(0.7, '#A0A0A0');
            screwGradient.addColorStop(1, '#808080');
            
            ctx.fillStyle = screwGradient;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Screw slot
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.lineWidth = 0.7;
            ctx.beginPath();
            
            // Phillips head (X pattern)
            ctx.moveTo(x - radius * 0.7, y - radius * 0.7);
            ctx.lineTo(x + radius * 0.7, y + radius * 0.7);
            ctx.moveTo(x + radius * 0.7, y - radius * 0.7);
            ctx.lineTo(x - radius * 0.7, y + radius * 0.7);
            
            ctx.stroke();
        }
        
        function drawRollerCover(ctx, x, y, width, height, paintLevel) {
            const radius = height / 2;
            const rotation = y % (Math.PI * radius * 2) / (Math.PI * radius * 2) * Math.PI * 2;
            
            // Base color for roller cover material
            ctx.save();
            
            // Create clipping region for the roller cylinder
            ctx.beginPath();
            ctx.arc(x, y + radius, radius, Math.PI / 2, -Math.PI / 2);
            ctx.arc(x + width, y + radius, radius, -Math.PI / 2, Math.PI / 2);
            ctx.closePath();
            ctx.clip();
            
            // Fill with base material color
            ctx.fillStyle = '#F0F0F0';
            ctx.fillRect(x - radius, y, width + radius * 2, height);
            
            // Create nap texture (fuzz on the roller)
            ctx.globalAlpha = 0.4;
            ctx.fillStyle = '#E0E0E0';
            
            // Draw nap texture that rotates with the roller
            for (let i = 0; i < width + radius * 2; i += 3) {
                for (let j = 0; j < height; j += 3) {
                    const angle = (i / (width + radius * 2)) * Math.PI * 2 + rotation;
                    const offset = Math.sin(angle) * 1.5;
                    
                    if (Math.random() > 0.3) {
                        ctx.fillRect(x - radius + i, y + j + offset, 1, 1 + Math.random() * 2);
                    }
                }
            }
            
            // Paint color with gradient
            const paintRatio = paintLevel / MAX_PAINT_CAPACITY;
            
            // Apply paint color with varying opacity based on paint level
            const gradientPaint = ctx.createLinearGradient(x, y, x, y + height);
            gradientPaint.addColorStop(0, paintColor);
            gradientPaint.addColorStop(1, shadeColor(paintColor, -30));
            
            ctx.fillStyle = gradientPaint;
            ctx.globalAlpha = 0.2 + 0.8 * paintRatio;
            ctx.fillRect(x - radius, y, width + radius * 2, height);
            
            // Add paint texture/variations
            if (paintRatio > 0.3) {
                ctx.fillStyle = shadeColor(paintColor, 15);
                ctx.globalAlpha = 0.1 * paintRatio;
                
                for (let i = 0; i < width + radius * 2; i += 5) {
                    for (let j = 0; j < height; j += 5) {
                        const angle = (i / (width + radius * 2)) * Math.PI * 2 + rotation;
                        const offset = Math.sin(angle) * 1.5;
                        
                        if (Math.random() > 0.7) {
                            const size = 2 + Math.random() * 3;
                            ctx.fillRect(x - radius + i, y + j + offset, size, size);
                        }
                    }
                }
            }
            
            ctx.restore();
            
            // Add a shine effect to emphasize the curved surface
            ctx.globalAlpha = 1.0;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x, y + radius - radius/3);
            ctx.lineTo(x + width, y + radius - radius/3);
            ctx.stroke();
            
            // Add another lighter highlight
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.moveTo(x, y + radius - radius/1.5);
            ctx.lineTo(x + width, y + radius - radius/1.5);
            ctx.stroke();
            
            // Drips if heavily loaded with paint
            if (paintRatio > 0.5) {
                ctx.fillStyle = paintColor;
                ctx.globalAlpha = 1.0;
                
                const numDrips = Math.floor(1 + paintRatio * 4);
                for (let i = 0; i < numDrips; i++) {
                    const dripX = x + Math.random() * width;
                    const dripHeight = 1 + Math.random() * 4 * paintRatio;
                    const dripWidth = 1 + Math.random();
                    
                    // Draw drip
                    ctx.beginPath();
                    ctx.moveTo(dripX, y + height);
                    ctx.lineTo(dripX + dripWidth, y + height);
                    ctx.lineTo(dripX + dripWidth/2, y + height + dripHeight);
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }
        
        function drawFlatBrush(ctx, x, y, width, height, paintLevel) {
            // Draw handle with wood grain
            drawHandle(ctx, x, y, width);
            
            // Metal ferrule with 3D effect
            const ferruleHeight = 8;
            const ferruleY = y - ferruleHeight;
            
            // Ferrule gradient (metallic)
            const ferruleGradient = ctx.createLinearGradient(x, ferruleY, x, ferruleY + ferruleHeight);
            ferruleGradient.addColorStop(0, '#C0C0C0');
            ferruleGradient.addColorStop(0.3, '#E8E8E8');
            ferruleGradient.addColorStop(0.7, '#A0A0A0');
            ferruleGradient.addColorStop(1, '#808080');
            
            ctx.fillStyle = ferruleGradient;
            
            // Ferrule with rounded top
            ctx.beginPath();
            ctx.moveTo(x, ferruleY + ferruleHeight);
            ctx.lineTo(x + width, ferruleY + ferruleHeight);
            ctx.lineTo(x + width - 1, ferruleY);
            ctx.lineTo(x + 1, ferruleY);
            ctx.closePath();
            ctx.fill();
            
            // Ferrule clamp lines
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(x, ferruleY + 2);
            ctx.lineTo(x + width, ferruleY + 2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(x, ferruleY + 6);
            ctx.lineTo(x + width, ferruleY + 6);
            ctx.stroke();
            
            // Highlight on top of ferrule
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.beginPath();
            ctx.moveTo(x + 1, ferruleY + 1);
            ctx.lineTo(x + width - 1, ferruleY + 1);
            ctx.stroke();
            
            // Bristles
            const bristleHeight = height;
            const bristleY = y;
            
            // Base color of bristles
            ctx.fillStyle = '#F8F8F8';
            
            // Draw bristle base shape
            ctx.beginPath();
            ctx.moveTo(x, bristleY);
            ctx.lineTo(x + width, bristleY);
            ctx.lineTo(x + width + 1, bristleY + bristleHeight);
            ctx.lineTo(x - 1, bristleY + bristleHeight);
            ctx.closePath();
            ctx.fill();
            
            // Paint color
            const paintRatio = paintLevel / MAX_PAINT_CAPACITY;
            const gradient = ctx.createLinearGradient(x, bristleY, x, bristleY + bristleHeight);
            gradient.addColorStop(0, paintColor);
            gradient.addColorStop(0.8, shadeColor(paintColor, -30));
            gradient.addColorStop(1, shadeColor(paintColor, -50));
            
            ctx.fillStyle = gradient;
            ctx.globalAlpha = 0.2 + 0.8 * paintRatio;
            
            // Draw painted bristles
            ctx.beginPath();
            ctx.moveTo(x, bristleY);
            ctx.lineTo(x + width, bristleY);
            ctx.lineTo(x + width + 1, bristleY + bristleHeight);
            ctx.lineTo(x - 1, bristleY + bristleHeight);
            ctx.closePath();
            ctx.fill();
            
            ctx.globalAlpha = 1.0;
            
            // Draw individual bristle lines
            ctx.strokeStyle = 'rgba(220, 220, 220, 0.5)';
            ctx.lineWidth = 0.5;
            
            for (let i = 0; i < width + 2; i += 1.5) {
                const bristleLength = bristleHeight - 1 + Math.random() * 2;
                const startX = x - 1 + i;
                
                // Get progressively more "splayed" toward the tip
                const endOffset = (Math.random() - 0.5) * 3;
                const controlOffset = (Math.random() - 0.5) * 2;
                
                ctx.beginPath();
                ctx.moveTo(startX, bristleY);
                
                // Use quadratic curve for slight bristle bend
                ctx.quadraticCurveTo(
                    startX + controlOffset, 
                    bristleY + bristleHeight * 0.6,
                    startX + endOffset, 
                    bristleY + bristleLength
                );
                ctx.stroke();
            }
            
            // Drips if heavily loaded with paint
            if (paintRatio > 0.5) {
                ctx.fillStyle = paintColor;
                const numDrips = Math.floor(1 + paintRatio * 3);
                
                for (let i = 0; i < numDrips; i++) {
                    const dripX = x - 1 + Math.random() * (width + 2);
                    const dripHeight = 1 + Math.random() * 4 * paintRatio;
                    const dripWidth = 1 + Math.random();
                    
                    // Draw drip
                    ctx.beginPath();
                    ctx.moveTo(dripX, bristleY + bristleHeight);
                    ctx.lineTo(dripX + dripWidth, bristleY + bristleHeight);
                    ctx.lineTo(dripX + dripWidth/2, bristleY + bristleHeight + dripHeight);
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }
        
        function drawPaintedArea(ctx, x, y, width, height, color, isRoller = false) {
            // Base color - full opacity
            ctx.fillStyle = color;
            ctx.fillRect(x, y, width, height);
            
            // Add a subtle texture based on brush type
            if (isRoller) {
                // Roller texture - more uniform with subtle pattern
                ctx.fillStyle = 'rgba(255, 255, 255, 0.04)';
                const patternSize = 5;
                for (let i = 0; i < width; i += patternSize) {
                    for (let j = 0; j < height; j += patternSize) {
                        if ((i + j) % (patternSize * 2) === 0) {
                            ctx.fillRect(x + i, y + j, patternSize, patternSize);
                        }
                    }
                }
                
                // Add subtle horizontal roller lines
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.lineWidth = 0.5;
                for (let j = 0; j < height; j += 10) {
                    const yOffset = Math.random() * 2;
                    ctx.beginPath();
                    ctx.moveTo(x, y + j + yOffset);
                    ctx.lineTo(x + width, y + j + yOffset);
                    ctx.stroke();
                }
            } else {
                // Flat brush texture - more streaky
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                for (let i = 0; i < width; i += 2) {
                    if (Math.random() > 0.7) {
                        const streakWidth = 1 + Math.random();
                        ctx.fillRect(x + i, y, streakWidth, height);
                    }
                }
                
                // Add brush stroke direction lines
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 0.5;
                for (let i = 0; i < width; i += 3) {
                    if (Math.random() > 0.5) {
                        ctx.beginPath();
                        ctx.moveTo(x + i, y);
                        ctx.lineTo(x + i, y + height);
                        ctx.stroke();
                    }
                }
            }
            
            // Edge effects - lighter at edges
            const gradient = ctx.createLinearGradient(x, y, x + width, y);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
            gradient.addColorStop(0.1, 'rgba(255, 255, 255, 0)');
            gradient.addColorStop(0.9, 'rgba(255, 255, 255, 0)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0.1)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, width, height);
        }
        
        function createSplatter(x, y, container, color) {
            const splatter = document.createElement('div');
            splatter.className = 'paint-splatter';
            splatter.style.left = `${x}px`;
            splatter.style.top = `${y}px`;
            splatter.style.backgroundColor = color;
            splatter.style.width = `${2 + Math.random() * 3}px`;
            splatter.style.height = `${2 + Math.random() * 3}px`;
            splatter.style.transform = `rotate(${Math.random() * 360}deg)`;
            
            container.appendChild(splatter);
            
            // Remove splatter after animation completes
            setTimeout(() => {
                splatter.remove();
            }, 1000);
        }
        
        function createPaintDrip(x, y, container) {
            const drip = document.createElement('div');
            drip.className = 'animated-drip';
            drip.style.left = `${x}px`;
            drip.style.backgroundColor = paintColor;
            container.appendChild(drip);
            
            // Create a few smaller drips nearby
            const smallDripsCount = Math.floor(Math.random() * 3) + 1;
            for (let i = 0; i < smallDripsCount; i++) {
                const offset = (Math.random() - 0.5) * 30;
                const smallDrip = document.createElement('div');
                smallDrip.className = 'animated-drip';
                smallDrip.style.left = `${x + offset}px`;
                smallDrip.style.backgroundColor = paintColor;
                smallDrip.style.width = `${1 + Math.random()}px`;
                smallDrip.style.opacity = '0.7';
                container.appendChild(smallDrip);
                
                // Remove drip after animation completes
                setTimeout(() => {
                    smallDrip.remove();
                }, 3000);
            }
            
            // Remove main drip after animation completes
            setTimeout(() => {
                drip.remove();
            }, 3000);
        }
        
        function checkCompletion() {
            if (rollerFinishTime && flatFinishTime) {
                const rollerTimeSeconds = rollerFinishTime / 1000;
                const flatTimeSeconds = flatFinishTime / 1000;
                const efficiencyFactor = (flatTimeSeconds / rollerTimeSeconds).toFixed(1);
                
                efficiencyFactorSpan.textContent = efficiencyFactor;
                resultText.classList.remove('hidden');
                
                stopAnimation();
            }
        }
        
        // Helper function to shade colors
        function shadeColor(color, percent) {
            let R = parseInt(color.substring(1, 3), 16);
            let G = parseInt(color.substring(3, 5), 16);
            let B = parseInt(color.substring(5, 7), 16);
            
            R = parseInt(R * (100 + percent) / 100);
            G = parseInt(G * (100 + percent) / 100);
            B = parseInt(B * (100 + percent) / 100);
            
            R = (R < 255) ? R : 255;
            G = (G < 255) ? G : 255;
            B = (B < 255) ? B : 255;
            
            R = Math.max(0, R);
            G = Math.max(0, G);
            B = Math.max(0, B);
            
            const RR = ((R.toString(16).length === 1) ? "0" + R.toString(16) : R.toString(16));
            const GG = ((G.toString(16).length === 1) ? "0" + G.toString(16) : G.toString(16));
            const BB = ((B.toString(16).length === 1) ? "0" + B.toString(16) : B.toString(16));
            
            return "#" + RR + GG + BB;
        }
        
        // Initialize paint color swatch
        colorSwatch.style.backgroundColor = paintColor;
    </script>
</body>
</html>